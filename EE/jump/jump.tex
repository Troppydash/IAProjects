\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,margin=1in,footskip=0.25in]{geometry}

% science
\usepackage{amsmath}
\usepackage{array}
\usepackage{siunitx}

% code
% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{10} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{10}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\usepackage{listings}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
        language=Python,
        basicstyle=\ttm,
        morekeywords={self},              % Add keywords here
        keywordstyle=\ttb\color{deepblue},
        emph={MyClass,__init__},          % Custom highlighting
        emphstyle=\ttb\color{deepred},    % Custom highlighting style
        stringstyle=\color{deepgreen},
        frame=tb,                         % Any extra options here
        showstringspaces=false
}}

\newcommand\pythonstyleln{\lstset{
        language=Python,
        basicstyle=\ttm,
        morekeywords={self},              % Add keywords here
        keywordstyle=\ttb\color{deepblue},
        emph={MyClass,__init__},          % Custom highlighting
        emphstyle=\ttb\color{deepred},    % Custom highlighting style
        stringstyle=\color{deepgreen},
        frame=tb,                         % Any extra options here
        showstringspaces=false,
        numbers=left
}}

% Python environment
\lstnewenvironment{python}[1][]
{
    \pythonstyle
    \lstset{#1}
}
{}

\lstnewenvironment{pythonln}[1][]
{
    \pythonstyleln
    \lstset{#1}
}
{}

% Python for external files
\newcommand\pythonexternal[2][]{{
        \pythonstyle
        \lstinputlisting[#1]{#2}}}

% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}

% layout
\usepackage{float}
\usepackage{parskip}
\usepackage{graphicx}
\usepackage{circuitikz}
\usepackage{longtable}
\usepackage{hyperref}
\usepackage[export]{adjustbox}
\usepackage{hhline}
\usepackage{chngcntr}

% referencing
\usepackage[style=apa]{biblatex}
\addbibresource{jump.bib}

% table centering
\renewcommand{\arraystretch}{1.3}
\newcolumntype{P}[1]{>{\raggedright\arraybackslash}p{#1}}
\newcommand{\tptt}{$\times\,$}

% figures labelings
\usepackage{chngcntr}
\counterwithin{figure}{section}

\usepackage{caption}
\usepackage{subcaption}
\usepackage{wrapfig}

% fancy page numbers
\usepackage{fancyhdr}
% bottom right
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[R]{\thepage}
\fancypagestyle{plain}{%
    \renewcommand{\headrulewidth}{0pt}%
    \fancyhf{}%
    \fancyfoot[R]{\thepage}%
}
%go
\renewcommand{\headrulewidth}{0pt}


\newcommand{\tvec}[1]{\boldsymbol{#1}}
\newcommand{\tunit}[1]{\boldsymbol{\hat{#1}}}
\newcommand{\tmag}[1]{\|#1\|}
\newcommand{\tang}[1]{\left\langle #1 \right\rangle}
\newcommand{\ta}{\tvec{a}}
\newcommand{\tv}{\tvec{v}}
\newcommand{\tp}{\tvec{p}}
\newcommand{\tpar}[2]{\begin{bmatrix}#1\\#2 \end{bmatrix}}
\newcommand{\tpars}[3]{\begin{bmatrix} #1\\#2\\#3 \end{bmatrix}}
\newcommand{\tfx}{\mathcal{X}}
\newcommand{\tfy}{\mathcal{Y}}


\linespread{1.25}

\usepackage{hyperref}

\title{The Optimization of Air Movements within a Video Game Jump Action}

\author{Word Count: $<$ 4000}
\date{}

\begin{document}

    \maketitle

    \newpage

    \tableofcontents

    \newpage

\section{Introduction}

\paragraph{Research Question:}
\begin{quote}
    To what extent can a player travel in distance/displacement through a jump action in optimistic conditions of vanilla settings, within the games made with the source engine?
\end{quote}

The problem originated my personal curiosity within the limitations of the video game ``Counter Strike'' that occupies a large part of my life. It came about as I was getting into the community of counter-strike long jumping --- a community aiming to exploit the video game's physics to achieve the longest jumping distance. Therefore I want to explore this optimization problem with various methods in an extended essay and to further improve my knowledge within this ``niche`` community by exploring the various forms of this question.

\subsection{Defining the problem}
The ``source'' engine (citation) is the base of plenty of popular videos games in terms of handling the players, their surroundings, and their respective physical interactions. It allows freedom in setting various engine constants that fit each video game's playstyle --- with the constants of ``Counter Strike - Source`` being used as a measure throughout this exploration. I will attempt to define the problem mathematically here.

% from p0 to p1, and to finishing this essay
\paragraph{Notations} Firstly, the notation used in the analysis are as follow:

All n-dimensional vectors are represented in bold styles like
\[
    \tvec{v},
\]
their magnitudes, or length are denoted by two double vertical lines, with the components of a vector written as a subscript $x$, $y$, or $z$ like
\[
    \tmag{\tvec{v}} = \sqrt{v_x^2 + v_y^2 + v_z^2}.
\]

The vector can also be expanded into its components, and is written with angled brackets or with parenthesis:
\[
    \tvec{v} = \tang{v_x, v_y, v_z} = \tpars{v_x}{v_y}{v_z}.
\]

The unit vectors are vectors scaled down by their magnitudes, resulting in a magnitude of 1, and is written with a hat on top:
\[
    \tunit{v} = \frac{\tvec{v}}{\tmag{v}}.
\]

The dot product between two vectors $\tvec{v}$ and $\tvec{w}$ is defined by
\[
    \tvec{v} \cdot \tvec{w} = v_x w_x + v_y w_y + v_z w_z + \ldots,
\]
but their cross product will not be used as it only applies in the third dimension.

Due to the nature of the source engine, the problem may be represented and optimized differently because of the use of discrete time frames rather than continuous time. But experimentally the differences are small and insignificant --- this will be shown later. Both approaches will thus be used, sometimes interchangeably.

The problem can be formally defined as so:
\begin{quote}
    Given initial position $\tvec{p}(0)$ and velocity $\tvec{v}(0)$ as three dimensional vectors when the player initializes a jump event, and a list of engine constants $S = \{j_0, j_1, j_2, \ldots\}$. If $\ta(t)$ is the acceleration vector function representing the player acceleration at every time $t$, with $\tv(t, S)$ and $\tp(t)$ being the respective derived velocity and position of the player at time $t$, what is the maximum displacement $\tmag{\tp(t_f) - \tp(0)}$ achievable if $t_f$ is the time when the player lands from the jump?
\end{quote}

\subsection{Source mechanics}
While the problem may look simple in the context of kinematics and projectile motions, the ``quirks'' in the source engine will increase its complexity. Therefore it is necessary to explore the specifics of the physics engine.

The engine time unit is in seconds; the engine distance unit is in hammerunits (hu), which are to be implied during all following calculations. The player's position and velocities are represented by $\tp$ and $\tv$ in the engine, of which they are updated every frame by the player controllable acceleration $\ta$. Commonly, the source engine runs at an integer number of frames per second (citation), $64$ will be used from now. Let $\tau$ be the time between frames (also know as $\Delta t$) and it has a value of $\tau = \frac{1}{64} \approx 0.0156 \si{s}$. For every $\tau$ seconds after $t=0$, the velocity is updated as so (citations):
\begin{enumerate}
    \item Apply gravitational acceleration
    \item Apply friction onto velocity
    \item Calculate magnitude of movement acceleration
    \item Apply movement acceleration
\end{enumerate}

% took 45 frames, v0 = 284hu/s, 60fps
\paragraph{Step 1} Let $g$ be the gravitational acceleration on the $z$ axis, it is set by an engine constant \verb|sv_gravity| (citations) --- set to $800$ within the game in question. Using a method called leapfrog interpolation, and let $\tv'$, $\tp'$ be the new velocity, position next frame of frame time $\tau$, the operation is (assuming $g$ is negative)
\begin{align}
    \tv'_z &= \tv_z + g\tau \label{eq:gv}\\
    \tp'_z &= \tp_z + \tv_z\tau + \frac{1}{2}g\tau^2 \label{eq:gp}.
\end{align}

Because the updates reflect the kinematic equations of a projectile with constant acceleration, it can be treated with assumptions of continuous time and will be evaluated separate to the $x$ and $y$ motions.


\paragraph{Step 2} Let $\lambda(\tv)$ be the friction function. For the player is in the air, no friction will be applied and we can set $\lambda(\tv) = \tv$.

\paragraph{Step 3} The source engine limits the velocity through an engine constant \verb|sv_maxspeed| ($L$) set to $30$ in air. However, the speed is limited by the projection of the velocity vector $\tv$ onto the acceleration vector $\ta$, with the player having control of $\ta$ at all times (picture).

Let $w$ be the magnitude of the applicable acceleration this frame. It can be defined as a piecewise function as
\[
    w = \begin{cases}
        \gamma_1 & \gamma_2 \ge \gamma_1\\
        \gamma_2 & \gamma_1 > \gamma_2 > 0\\
        0 & 0 \ge \gamma_2
    \end{cases}
\]
where $\gamma_1$ represents the upper-bound of acceleration and is proportional to the engine constant \verb|sv_airacclerate| ($A$), and \verb|sv_maxspeed| ($L$); $\gamma_2$ represents signed the difference between $L$ and the projected velocity.

When $\gamma_2$ is negative, meaning the projected velocity is larger than the max speed, no acceleration will occur and $w=0$; when $\gamma_2$ is positive but below $\gamma_1$, meaning that adding the full acceleration will overshoot the max speed, only the difference between the max speed and the current projected velocity is applied, bringing the player to the speed limit on the next frame and $w=\gamma_2$; when $\gamma_2$ is larger than $\gamma_1$, only the upper-bound acceleration is applied and $w=\gamma_1$.

The definition of $\gamma_1$ and $\gamma_2$ are:
\begin{align*}
    \gamma_1 &= LA\tau\\
    \gamma_2 &= L - \tv \cdot \tunit{\ta},
\end{align*}
where the dot product $\tv \cdot \tunit{\ta}$ with the unit acceleration vector represents the projection of velocity.

\paragraph{Step 4} The new velocity on the next frame $\tv'$ (note that we assume step 1 has already been applied this frame) is the combination between the friction and movement acceleration:
\[
    \tv' = \lambda(\tv) + w \tunit{\ta},
\]
with the position being updated without interpolation ($\tp'$):
\[
    \tp' = \tp + \tv' \tau.
\]

% jumping mechanics
% took 45 frames, v0 = 284hu/s, 60fps
Additionally, the mechanics of initiating a jump action can also be modelled mathematically. By recording myself jumping ingame at 60 frames per second (picture), I've obtained that a jump is represented by an impulse applied on the player, setting its z-axis velocity to around $+280\pm10$ the frame after jumping. The player then takes around $45 + \pm1$ video frames to land, meaning an airtime of $45\pm1 / 60 =0.75\pm 0.02\si{s}$. Therefore the initial velocity is restricted by $\tv_z = 280\pm10$.

% summarize
To summarize, every $\tau$ seconds after $t=0$ the velocity is updated by gravity in the z-axis, and by the player's movement acceleration in the x,y-axis. The latter is limited so that the projection of the new velocity never exceeds the engine constant \verb|sv_maxspeed| of 30 in air. Therefore for some time $t$, the velocity next frame $\tv(t+\tau)$ is
\begin{align*}
    \tv(t+\tau) &= \tang{\lambda(\tv_x(t)) + w \tunit{a}_x, \lambda(\tv_y(t)) + w\tunit{a}_y,\tv_z(t) + g\tau}\\
    \tp(t+\tau) &= \tang{\tp_x(t) + \tv(t+\tau)_x \tau, \tp_y(t) + \tv(t+\tau)_y \tau, \tp_z(t) + \tv_z(t)\tau + \frac{1}{2}g\tau^2}.
\end{align*}

The velocity update can be represented in code for simulation, shown in appendix (citation).

\section{Vertical motion}
Universal across the various metrics are the vertical motion of the player. Firstly notice that the z-axis motion is separated from the x,y-axis motion, meaning that it can be computed on its own.

Let $p$, $v$, $a$ be the z-axis position, velocity, and acceleration as a function of time $t$ and engine constants $S$, also define $p_0$, $v_0$ to be the initial conditions. Because of the velocity update in equation \ref{eq:gv}:
\[
    \frac{\Delta v}{\tau} = g,
\]
because $\tau$ is very small, it can be assumed that:
\[
    v' = g.
\]
Similarly, the position update can also be assumed to be continuous (equation \ref{eq:gp}):
\begin{align*}
 \frac{\Delta p}{\tau} &= v(t+\tau)\\
 p' &= v.
\end{align*}
Therefore it is possible to compute the airtime of the player upon a jump action. For the acceleration of gravity is constant, the kinematic equations may be used (citation).
\begin{align*}
    s &= s_0 + ut + \frac{1}{2} a t^2\\
    0 &= 0 + v_0 t + \frac{1}{2} g t^2\\
    \text{therefore:}&\\
    t &= \frac{-v_0 \pm \sqrt{v_0^2}}{g}\\
    &= \frac{-2v_0}{g} \,\, \text{or} \,\, 0.
\end{align*}
Because $t=0$ is the first frame when the player executes the jump action, the airtime is the first root of the quadratic, and therefore:
\begin{align*}
    t &= -2 \frac{v_0}{g}\\
    &= -2 \times \frac{280\pm 10}{-800}\\
    &= 0.70 \pm 0.03 \si{s}
\end{align*}

The result is very similar to the recorded airtime of $0.75\pm 0.02$ with their uncertainty overlapping, the assumption of a small $\tau$ may also contribute to the difference between the observed with the calculated time. This airtime will be denoted by the symbol $t_f$.

Therefore if the initial displacement at $t=0$ ($\tp(0)$) has a length of zero, the total displacement as a result of the jump is $\tmag{\tp(t_f)}$.

\section{Jumping motion}
% main is with straight jumping
I will consider and evaluate multiple models to maximize the displacement jumped, this will include the modeling of the player motions as an differential equation assuming continuous time, then going discrete and maximize the displacement frame by frame.

\subsection{Equations of motion}
First let us construct the differential equations that govern the player motion, maybe the answer is as simple as an optimization problem. Let $\ta$, $\tv$, and $\tp$ be the two dimensional acceleration, velocity, and position. It is assumed that player can perfectly control $\ta$ at all time $t \in [0, t_f]$ via their keyboard and mouse --- the time period $t\in[0,t_f]$ will be assumed for all functions in this section.

Initially consider the case without any maximum velocity restrictions (with scalar $w$ being constant for all considered time), the acceleration is:
\begin{align*}
 \ta = w\tunit{a} = w\tpar{x(t)}{y(t)},
\end{align*}
where $x(t)$ and $y(t)$ are functions of time and is a unit vector where
\[
    x^2 + y^2 = 1.
\]

The velocity at any point is the time integral of the acceleration, which can be expanded into the x,y components like so:
\begin{align*}
    \tv &= \int w\tunit{a} \,dt + c\\
    &= \tpar{\int w x(t) \,dt}{ \int w y(t) \,dt} + \tpar{c_x}{c_y}\\
    &= w\tpar{X(t)}{Y(t)} + \tpar{c_x}{c_y},
\end{align*}
where $X(t)$ and $Y(t)$ are the time integrals of $x(t)$ and $y(t)$.

The constants ($c_0$,$c_1$) can be found by plugging in $t=0$, for we can define the constants in terms of the initial velocities:
\begin{align*}
    v_0 &= w \tpar{X(0)}{Y(0)} + \tpar{c_x}{c_y}\\
    c_x &= -wX(0)\\
    c_y &= -wY(0).
\end{align*}

The displacement $\tp$ is the time integral of the velocity:
\begin{align*}
    \tp &= \int \tv \, dt + k\\
    &= w \tpar{\int X(t) \, dt + tc_x}{\int Y(t) \, dt + tc_y} + \tpar{k_x}{k_y}\\
    &= w \tpar {\tfx(t) + tc_x}{\tfy(t) + tc_y} + \tpar{k_x}{k_y},
\end{align*}
where $\tfx$ and $\tfy$ are the time integral of $X$ and $Y$.

The constants $k_x$ and $k_y$ can be found by evaluating at $t=0$:
\begin{align*}
    \tp_0 &= w \tpar{\tfx(0)}{\tfy(0)} + \tpar{k_x}{k_y} = \tpar{0}{0}\\
    k_x &= -w\tfx(0)\\
    k_y &= -w\tfy(0).
\end{align*}

Therefore, the position of the player, when $L >> 0$, at all time $t$ in the respective domain is (notice that $\tfx'(t) = X(t)$ and $\tfy'(t) = Y(t)$):
\begin{align*}
 \tp(t)_x &= w(\tfx(t) - w\tfx'(0)t) - w\tfx(0)\\
 \tp(t)_y &= w(\tfy(t) - w\tfy'(0)t) - w\tfy(0).
\end{align*}

\subsection{Restrictions}
Step 3 states that the velocity is limited through the projection of the current velocity onto the player acceleration. I thought to define the restrictions so that maximum acceleration magnitudes are achieved at all time.

The maximum magnitudes of velocity after every frame is achieved when $L- v \cdot \tunit{a} \ge LA\tau$, for then $\gamma_2 \ge \gamma_1$ and $w = \gamma_1$, for this ensures that acceleration is at a maximum. Additionally, we can see that both the $x$ and $y$ position are positively correlated to $w$, meaning that its maximization will result in higher overall displacement. However, I wonder if this is accurate for the new velocity $\tv'$ is the sum of current velocity with the acceleration, the angle between $\tunit{a}$ and $\tv$ dictates the magnitude of the updated velocity --- could it sometimes be worth it to forgo maximum acceleration to decrease the angle, resulting in a higher updated velocity?

For now, consider the restriction so that acceleration will be maximized at all $t$ in the time domain:
\begin{align*}
    L - v \cdot \tunit{a} &\ge LA\tau\\
    L - (v_x \tunit{a}_x + v_y \tunit{a}_y) &\ge LA\tau.
\end{align*}

Notice that $\tunit{a}_x = x(t)$ and $\tunit{a}_y = y(t)$ and:
\begin{align*}
    v_x &= wX(t) + c_x\\
    v_y &= wY(t) + c_y,
\end{align*}
therefore:
\begin{align*}
 L - x(t)(wX(t)+c_x) - y(t)(wY(t)+c_y) &\ge LA\tau\\
    L - LA\tau &\ge x(t)(wX(t)+c_x) + y(t)(wY(t)+c_y)\\
    L - LA\tau &\ge x(t)(wX(t)-wX(0)) + y(t)(w(Y)-wY(0))\\
    \frac{L - LA\tau}{w} &\ge X'(t)(X(t)-X(0)) + Y'(t)(Y(t)-Y(0))\\
    \frac{1}{A\tau} - 1 &\ge X'(t)(X(t)-X(0)) + Y'(t)(Y(t)-Y(0)),
\end{align*}
because $w=\gamma_1=LA\tau$.

This restriction shows that for acceleration each frame to be maximized, the RHS must be less than the LHS constant for all $t \in [0, t_f]$.

\section{Models}
With the question defined, the equations of motion derived, we can now consider the different models to achieve maximum displacement from a single jump.

\subsection{Do nothing}















\section{Displacement Jumping with angle}
% extension is displacement given angle.








\nocite{*}
\newpage
\printbibliography

\end{document}
